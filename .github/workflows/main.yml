name: ğŸ” Sync upstream Releases via API

on:
  schedule:
    - cron: '0 2 * * *'      # æ¯å¤© UTC 2:00 åŒæ­¥
  workflow_dispatch:         # æ‰‹åŠ¨è§¦å‘

permissions:
  contents: write            # åˆ›å»º Release éœ€è¦å†™å†…å®¹æƒé™
  packages: read             # è¯»å– assets
  id-token: write            # å¦‚æœä½ ç”¨ OIDC è·å–ä»¤ç‰Œï¼ˆå¯é€‰ï¼‰

jobs:
  sync_releases:
    runs-on: ubuntu-latest
    steps:

      - name: Checkout (ä»…ç”¨äº github-script ä¸Šä¸‹æ–‡)
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Install jq for JSON parsing
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Sync Releases from upstream
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.WORKFLOW_TOKEN }}  # æˆ–ç›´æ¥ä½¿ç”¨ GITHUB_TOKENï¼ˆå¸¦å†™æƒé™ï¼‰
          script: |
            const upstreamOwner = 'homuler';
            const upstreamRepo  = 'MediaPipeUnityPlugin';
            const myOwner       = context.repo.owner;
            const myRepo        = context.repo.repo;

            // 1. è·å–ä¸Šæ¸¸æ‰€æœ‰ releases
            const upstreamReleases = await github.rest.repos.listReleases({
              owner: upstreamOwner,
              repo: upstreamRepo,
              per_page: 100
            });

            for (const rel of upstreamReleases.data) {
              // 2. æ£€æŸ¥ç›®æ ‡ä»“åº“æ˜¯å¦å·²æœ‰è¯¥ tagName çš„ Release
              let exists;
              try {
                await github.rest.repos.getReleaseByTag({
                  owner: myOwner,
                  repo: myRepo,
                  tag: rel.tag_name
                });
                exists = true;
              } catch (e) {
                exists = false;
              }

              if (!exists) {
                // 3. åˆ›å»º Release
                const created = await github.rest.repos.createRelease({
                  owner: myOwner,
                  repo: myRepo,
                  tag_name: rel.tag_name,
                  name: rel.name,
                  body: rel.body,
                  draft: rel.draft,
                  prerelease: rel.prerelease
                });
                console.log(`Created release ${rel.tag_name}`);

                // 4. å¤åˆ¶ assets
                const assets = await github.rest.repos.listReleaseAssets({
                  owner: upstreamOwner,
                  repo: upstreamRepo,
                  release_id: rel.id
                });
                for (const asset of assets.data) {
                  // ä¸‹è½½äºŒè¿›åˆ¶æ•°æ®
                  const download = await github.request({
                    url: asset.url,
                    headers: { accept: 'application/octet-stream' }
                  });
                  // ä¸Šä¼ åˆ°æ–° Release
                  await github.rest.repos.uploadReleaseAsset({
                    owner: myOwner,
                    repo: myRepo,
                    release_id: created.data.id,
                    name: asset.name,
                    data: download.data
                  });
                  console.log(`  + asset: ${asset.name}`);
                }
              } else {
                console.log(`Release ${rel.tag_name} already exists, skipping.`);
              }
            }
